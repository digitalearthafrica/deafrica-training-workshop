# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, Digital Earth Africa
# This file is distributed under the same license as the Digital Earth
# Africa Training package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2020.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Digital Earth Africa Training \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-11-23 20:29+1100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:9
msgid "Understanding geomedians: 1 pixel, 3 timesteps"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:20
msgid ""
"When we want to make a single image that represents a period of time from"
" satellite data, we use a method known as compositing. This notebook will"
" help you to experiement with two similar (but subtly different) "
"compositing methods, known as the ``median`` and ``geomedian``."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:22
msgid ""
"In this example, you have a dataset of Earth observation satellite data. "
"It contains the red, green, and blue bands, which are used to generate "
"colour images. We will focus on a single pixel that has data for 3 "
"different timesteps. We can composite (combine) these 3 timesteps into "
"one using a statistical composition method such as ``median`` or "
"``geomedian``."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:33
msgid ""
"**Note**: To run the app and experiment with different pixel colours, "
"follow the instructions in the **Interactive app** section. To view a "
"pre-run example and learn more about geomedians and medians, see the "
"**Pre-run example** section."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:45
msgid "Interactive app"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:47
msgid ""
"To run this notebook, go to the main menu bar and select ``Run`` -> "
"``Restart Kernel and Run All Cells...``. Click ``Restart``. The notebook "
"may take a few minutes to finish computing. You will know it is complete "
"when you see the app appear (it will look like the example in the next "
"session, but you will be able to move the sliders)."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:49
msgid ""
"Use the sliders to change the colour of the pixels at each timestep. "
"Observe how this impacts the median and geomedian results."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:60
msgid ""
"**Note**: The RGB colour model uses values from 0 – 255. This is the "
"range that has been used here. Spectral datasets are scaled to fit this "
"range."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:175
msgid ""
"**Note**: The widget code is hidden by the ``...`` symbol above. Clicking"
" on it will expand the code cell. Click on the vertical blue line next to"
" the left of the cell to collapse it again."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:187
msgid "Pre-run example"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:198
msgid ""
"The geomedian is regarded as the better composition method as it accounts"
" for the multi-dimensional relationship between the satellite spectral "
"bands. This is evident in the example below. One timestep is shows a "
"black pixel, one a white pixel, and one a fully saturated green pixel."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:209
msgid "|image.png|"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:222
msgid ""
"*The image above is an example of a dataset where the median and "
"geomedian are different. Note this is a static image, not a widget.*"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:234
msgid "Interpreting the example"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:236
msgid ""
"The median can be determined for each band by finding the middle value "
"over the three time steps. In the above example, for the three timesteps,"
" the red band has the values (``0``, ``0``, ``255``). When arranged in "
"order of increasing value, we find that the value ``0`` occupies the "
"middle space of the three numbers, hence the median for the red band is "
"0. For each of the bands:"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:238
msgid "The median of the red band is ``median(0, 0, 255) = 0``."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:240
msgid "The median of the green band is ``median(0, 255, 255) = 255``."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:242
msgid "The median of the blue band is ``median(0, 0, 255) = 0``."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:244
msgid ""
"Thus the median RGB value for all timesteps is ``(0, 255, 0)``, with the "
"corresponding colour shown in the **Median RGB - All timesteps** pixel. "
"Note that the median RGB value is the same as the green pixel (``Timestep"
" 2``)."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:247
msgid "The problem with the median"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:249
msgid ""
"This example shows that the median does **not** account for the fact that"
" one of the ``red`` values and one of the ``blue`` values are very large "
"(255). Likewise, one of the ``green`` values is very small (0). We find "
"that the median comes out to the same value as ``Timestep 2``, which is "
"not particularly representative of the variation we see in the three "
"timesteps."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:251
msgid ""
"The variation is better incorporated into the ``Geomedian RGB - All "
"timesteps`` result, as the geomedian formula treats each timestep as a "
"multi-dimensional vector. We see this results in differing values between"
" the median and geomedian."
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:254
msgid "Further exploration"
msgstr ""

#: ../../_static/other_information/Geomedian_interactive_extend1.ipynb:256
msgid ""
"If there is only one spectral dimension (e.g. only the red band), the "
"median and geomedian can still be different. You can try this for "
"yourself by setting all ``Green`` and ``Blue`` sliders to ``0``. Can you "
"create a case where the red median and red geomedian are different?"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:9
msgid "Session 2 Solution - Loading data exercise"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:21
#: ../../_static/session_3/Geomedian_composite_solution.ipynb:21
#: ../../_static/session_5/Vegetation_exercise.ipynb:21
#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:21
msgid "Set up notebook"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:33
#: ../../_static/session_3/Geomedian_composite_solution.ipynb:33
#: ../../_static/session_5/Vegetation_exercise.ipynb:33
#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:33
msgid "Load packages and functions"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:61
#: ../../_static/session_3/Geomedian_composite_solution.ipynb:64
#: ../../_static/session_5/Vegetation_exercise.ipynb:75
#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:75
msgid "Connect to the datacube"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:82
msgid "Load Landsat 8 data"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:94
#: ../../_static/session_3/Geomedian_composite_solution.ipynb:97
msgid "Set area of interest and view on map"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:118
msgid "Load Landsat data"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:148
msgid "Examine Landsat data"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:169
msgid "Plot a true-colour image of Landsat data"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:190
msgid "Repeat load exercise for Sentinel-2"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:193
#: ../../_static/session_3/Geomedian_composite_solution.ipynb:85
#: ../../_static/session_3/Geomedian_composite_solution.ipynb:121
msgid "Load Sentinel-2 data"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:223
msgid "Examine Sentinel-2 data"
msgstr ""

#: ../../_static/session_2/Load_data_solution.ipynb:244
msgid "Plot a true-colour image of Sentinel-2 data"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:9
msgid "Session 3 Solution - Cloud mask and geomedian composite exercises"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:151
#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:202
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:191
msgid "Plot timesteps"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:163
msgid "Plot a true-colour image for the first timestep"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:184
msgid "Plot a true-colour image for all timesteps"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:205
msgid ""
"*The cloud mask exercise ends here. The geomedian composite exercise "
"continues from this point.*"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:217
msgid "Check dataset"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:238
msgid "Calculate geomedian"
msgstr ""

#: ../../_static/session_3/Geomedian_composite_solution.ipynb:259
msgid "Plot true-colour geomedian image"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:9
msgid "Session 4 Solution - Calculate NDVI Part 1 Exercise"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:21
msgid "Running the notebook"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:33
msgid "Set up"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:75
msgid "Load the data"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:86
msgid ""
"In the following cell, we set ``x`` and ``y`` equal to pairs indicating "
"the longitude and latitude extents of our region of interest, and then "
"display a map showing the region."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:143
msgid ""
"Here we load data via the ``load_ard`` function. We specify the instance "
"of the datacube (``dc``), the product that we wish to load (``s2_l2a`` "
"for Sentinel-2), the extents of our query (in ``x``, ``y``, and "
"``time``), the list of bands to fetch (``['red' ,'green', 'blue']``), the"
" spatial resolution of our data (10 meters), and we group nearby results "
"by solar day."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:145
msgid ""
"Note we named the variables ``x`` and ``y`` in the cell above, so we do "
"not need to type the longitude/latitude pairs again. We can just call "
"upon ``x`` and ``y`` as shown below."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:213
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:202
msgid ""
"Here we create a list of time slices to plot, and store it as the "
"variable ``timesteps``. The values in the list are indices into the list "
"of satellite acquisitions, starting at zero. The values here, ``[1, 6, "
"8]``, therefore refer to the second, seventh, and ninth acquisitions. "
"There should be 71 acquisitions for this particular dataset/extent "
"combination, so any values from 0 to 70 can be used."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:215
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:204
msgid ""
"We then call the ``rgb`` function to produce a series of plots from the "
"data that we loaded, using the bands that we specify (``['red', 'green', "
"'blue']``), for the time indices stored in ``timesteps``."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:247
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:236
msgid "Resampling the dataset"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:258
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:247
msgid ""
"Here we create a new variable (``resample_sentinel_2_ds``) which "
"describes a grouping of the data we previously loaded "
"(``sentinel_2_ds``), divided into 3-month (quarterly) intervals."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:280
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:269
msgid "Compute the geomedian"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:291
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:280
msgid ""
"Below, we take the data which we just split into quarterly intervals, and"
" we apply the ``xr_geomedian`` function to each interval. We store the "
"result into the ``geomedian_resample`` variable."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:331
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:320
msgid "Comparing the two datasets"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_1_solution-annotated.ipynb:342
#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:331
msgid ""
"In the next two cells, we simply print our datasets to screen. The first "
"cell contains the data that we originally loaded from the Open Data Cube,"
" and the second cell contains the data after resampling it into quarterly"
" geomedian composites. Note that the first dataset contains many more "
"time slices than the second."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:9
msgid "Session 4 Solution - Calculate NDVI Part 2 Exercise"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:21
msgid "Open and run notebook"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:62
msgid ""
"In the following cell, we set x and y equal to “tuples” (pairs) "
"indicating the longitude and latitude extents of our region of interest, "
"and then display a map showing the region."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:120
msgid "Making changes to the load cell"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:123
msgid "Adding nir measurement"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:134
msgid ""
"Here we load data via the ``load_ard`` function. We specify the instance "
"of the datacube (``dc``), the product that we wish to load (``s2_l2a`` "
"for Sentinel-2), the extents of our query (in x, y, and time), the list "
"of bands to fetch (``['red' ,'green', 'blue', 'nir']``), the spatial "
"resolution of our data (20 meters), and we group nearby results by solar "
"day."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1612
msgid "Manually calculate an index"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1615
msgid "Calculate NDVI"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1626
msgid ""
"In the following cell, we compute NDVI values from our resampled data "
"using the formula:"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1628
msgid "NDVI = \\frac{(NIR - Red) }{ (NIR + Red)}"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1630
msgid ""
"To keep our code tidy, we create variables ``nir`` and ``red`` and set "
"them to equal ``geomedian_resample.nir`` and ``geomedian_resample.red`` "
"respectively."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1655
msgid "Plot NDVI for each geomedian"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1666
msgid ""
"Here we call the ``plot`` function on our NDVI data, which gives us an "
"image for each quarterly interval."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1717
msgid "Plot time series of the NDVI area"
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1728
msgid ""
"The following cell generates a plot of the mean NDVI over time. Note that"
" we specify the dimensions along which to take the mean (``dim=['x', "
"'y']``). It is important that we omitted the ``time`` dimension — if we "
"had included it, our mean would collapse the data along *every* "
"dimension, returning only a single value (the mean value in x, y, *and* "
"time)."
msgstr ""

#: ../../_static/session_4/Calculate_NDVI_Part_2_solution-annotated.ipynb:1778
msgid ""
"Finally, we decorate the plot from the previous cell by adding a title "
"and a label for our Y axis."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:9
msgid "Exercise: Vegetation change detection"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:63
msgid ""
"Note that we have imported one new function for this exercise in the cell"
" above: ``calculate indices``."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:86
msgid ""
"We create a new connection to the Open Data Cube, and store it as the "
"variable ``dc``."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:107
msgid ""
"For this exercise, we will select our area of interest by picking a "
"centre point and specifying a ``buffer`` of space (in degrees) on all "
"sides of it. We also create a variable called ``time_baseline`` which "
"specifies a time in the middle of our date range which will be used to "
"split the data into two groups later."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:141
msgid ""
"We use the ``display_map`` function to visualize the extents which will "
"be loaded."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:196
#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:237
msgid "Load data"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:207
msgid ""
"In the following cell, we use the ``load_ard`` function to request data "
"from the Open Data Cube, and we store it into the ``landsat_ds`` "
"variable. Loading the data will take a moment, but we should end up with "
"46 time steps."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:271
msgid "Calculate Indices"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:282
msgid ""
"Below, we will use the ``calculate_indices`` function to add a new "
"variable called ``EVI`` to our dataset, and we replace the original "
"``landsat_ds`` with our modified version."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:304
msgid "Detect Changes"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:315
msgid ""
"Now we will use ``slice`` and ``sel`` to split our time series into two "
"pieces and store the EVI data from each part into a variable:"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:317
msgid ""
"``baseline_sample`` will contain data between the *first* date in our "
"``time`` variable (``'2013-01-01'``) and the date we stored as "
"``time_baseline`` (``'2015-12-31'``)"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:318
msgid ""
"``postbaseline_sample`` will contain data between the ``time_baseline`` "
"and the *second* date stored in our ``'time'`` variable "
"(``'2018-12-01'``)"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:320
msgid ""
"Remember that Python numbering starts at zero, so ``time[0]`` is the "
"first entry, and ``time[1]`` is the second."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:343
msgid "Detect per-pixel changes"
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:354
msgid ""
"First, we will use the ``mean`` function to find the average of all "
"pixels in each of the new datasets along the time axis."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:376
msgid ""
"Next, we will calculate the difference between the two mean mosaics and "
"store that as ``diff_mean_composites``."
msgstr ""

#: ../../_static/session_5/Vegetation_exercise.ipynb:397
msgid "Finally, we plot the difference."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:9
msgid "Exercise: Determining the extent of water bodies"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:44
msgid ""
"We begin this notebook with our standard set of initial configuration "
"lines to import packages and functions we need. We also import one new "
"function for this exercise: ``wofs_fuser``. The ``wofs_fuser`` function "
"is used to combine WOfS data from multiple scenes."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:86
msgid ""
"We create a new connection to the Open Data Cube, and save it into the "
"variable ``dc``."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:108
msgid "Select area of interest"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:119
msgid ""
"Below, we save the lat/lon extents of our area of interest into variables"
" that we will use to load the data. We use the ‘buffer method’ to define "
"the area in terms of a center point plus or minus a buffer of 0.2 "
"degrees. In the previous exercie we used a single buffer variable for "
"both latitude and longitude; this time we will define both a "
"``lat_buffer`` and a ``lon_buffer`` so that we can easily define a "
"rectangular region of interest."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:196
msgid "Create query object"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:207
msgid ""
"In the following cell, we create a Python dictionary and assign it to the"
" variable ``query``. Dictionaries are key-value stores, which means that "
"a value stored in a dictionary can be retrieved using the key under which"
" it was stored. In the dictionary below, for example, we define a key "
"called ``'x'``, and store the ``lon_range`` under that key. Creating a "
"dictionary to store some or all of the values that we use to load our "
"data can help to keep our code organized, and makes it easier to reuse "
"the parameters in subsequent loads. Below, we will use ``query`` in two "
"separate calls to ``load_ard`` to load two sets of data (Landsat 8 and "
"WOfS)."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:249
msgid "Load Landsat 8"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:260
msgid ""
"Note that the following call to ``load_ard`` omits several of the "
"parameters we’re used to seeing (such as the extents and resolution). "
"Instead we use the ``query`` variable that we defined above. Passing "
"``**query`` tells Python to send each of the values stored in the "
"dictionary to ``load_ard`` as if we had supplied that value for the "
"parameter identified by the corresponding key. For example, since the "
"``query`` dictionary defines ``'x'`` to be ``lon_range``, it is as if we "
"had included the usual ``x = lon_range,`` line in our call to "
"``load_ard``."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:880
msgid "Load WOfS"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:891
msgid ""
"For the WOfS product, we use the ``dc.load`` call. We can also pass the "
"``query`` dictionary to ``dc.load``, which will reuse the same values "
"that we used in the previous cell."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:1397
msgid "Calculating water extent"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:1409
msgid "Extract the water pixels"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:1420
msgid ""
"Using the table shown in the exercise, we determined that we want to "
"examine all pixels in the WOfS product which have a value equal to 128. "
"We create a new variable, ``ds_valid_water``, which stores the locations "
"of all pixels in the dataset which are equal to 128. Note this requires "
"the double equals sign ``==``."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:1441
msgid ""
"When we view the contents of the ``ds_valid_water`` variable, we can see "
"that it contains a grid of True/False values. Wherever ``ds_wofs.water`` "
"was equal to 128, the array will be True. Note that the preview below "
"only shows a small subset of the full DataArray, and there may not be any"
" True pixels visible in the preview output."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2047
msgid "Calculate the area per pixel"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2058
msgid ""
"We can calculate the area of a pixel by converting its resolution (which "
"we specified in meters per pixel in our ``query`` variable’s "
"``'resolution'`` key) into square kilometers per pixel:"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2082
msgid "Calculate area of water pixels"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2093
msgid ""
"Now that we know how many square kilometers a pixel represents, we can "
"take that number and multiply it by the count of all pixels containing "
"water in order to get the total water area in our dataset."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2116
msgid "Plot Time Series"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2127
msgid ""
"The following lines of code create a new ``figure`` which will contain a "
"plot of our water area data, complete with custom titles, axis labels, "
"etc."
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2162
msgid "Display of water coverage for a selected timestep"
msgstr ""

#: ../../_static/session_6/Water_extent_exercise-solution.ipynb:2173
msgid ""
"Finally, we choose one of the times in our time series to generate more "
"customised plots of both the Landsat and WOfS datasets. Here we have "
"chosen timestep ``4`` (the fifth time in the series, since we start "
"counting at zero) but you are encouraged to experiment with other time "
"indices to find times where the lake has dried out (the line plot above "
"may provide some hints!)."
msgstr ""

